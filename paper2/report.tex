\documentclass[sigconf]{acmart}

\input{format/i523}

\begin{document}

\title{Using MQTT for Communication in IoT Applications}


\author{Arnav}
\affiliation{%
  \institution{Indiana University Bloomington}
  \city{Bloomington} 
  \state{Indiana} 
  \postcode{47408}
}
\email{aarnav@iu.edu}

\author{Gregor von Laszewski}
\affiliation{%
  \institution{Indiana University}
  \streetaddress{Smith Research Center}
  \city{Bloomington} 
  \state{IN} 
  \postcode{47408}
  \country{USA}
}
\email{laszewski@gmail.com}


% The default list of authors is too long for headers}
% \renewcommand{\shortauthors}{G. v. Laszewski}


\begin{abstract}

  With the increase in the number of edge devices and their
  applications in real world applications such as sensor networks, it
  is crucial to
  enable fast communication between the sensing devices and actuators, which
  may not be directly connected. To allow services that are built on 
  different software and hardware platforms to communicate, a
  data agnostic, fast and reliable mechanism is needed to allow
  communication between these devices. In addition to communication,
  the data generated by these devices must be analyzed and security of
  this data is highly important. MQTT is a common, easy to use, queuing
  protocol that helps meet these requirements.
  We have evaluated the feasibility of using MQTT with the help of
  sentient architecture inspired dendrites.

\end{abstract}

\keywords{i523, HID201, MQTT, IoT, Edge Computing, Security}


\maketitle



\section{Introduction}

As Internet of Things (IoT) applications and sensor networks become
commonplace and more and more devices are being connected, there is an
increased need to allow these devices to communicate quickly and
securely. In many cases these edge devices have very limited memory
and need to conserve power. The computing power on some of these
devices is so limited that the sensory data need to be analyzed
remotely. Furthermore, they may not even have enough computing
capacity to process traditional HTTP web requests efficiently
\cite{mqtt-vs-http,hivemq-website} or these traditional Web-based
services are too resource hungry. Monitoring the state of a remotely
located sensor using HTTP would require sending requests and receiving
responses to and from the device frequently, which may not be
efficient on small circuits or embedded chips on edge computing
sensors \cite{mqtt-vs-http}.

Message Queue Telemetry Transport (MQTT) is a lightweight machine to
machine (M2M) messaging protocol, based on a client/server 
publish-subscribe model. It provides an elegant solution for such
scenarios.

\TODO{WHICH SCENARIOS}.

MQTT was first developed in 1999 by Andy Stanford-Clark and
Arlen Nipper to connect oil pipelines \cite{hivemq-website}. The
protocol has been designed to be used on top of TCP/IP protocol in
situations where network bandwidth, and available memory are limited
allowing low power usage. However du to leveraging TCP/IP it is
reliable. It allows efficient transmission of data to
various devices listening for the same event, and is scalable as the
number of devices increase \cite{mqtt-wiki}\cite{mqtt-official}.

The current support for MQTT is conducted by the Eclipse Paho project \cite{eclipse-mosquitto}.

As MQTT is a protocol many different clients exist in 
various languages. This includes languages such as C, Python and Lua. 

Common brokers include the open
source Mosquitto broker \cite{mqtt-official} and a Really Small Message Broker from IBM
\cite{eclipse-mosquitto}.
\TODO{what is the real small broker, this seems unclear}.


\section{MQTT Details}

MQTT works via a publish-subscribe model that contains 3 entities: (1) a
publisher, that sends a message, (2) a broker, that maintains queue of all
messages based on topics and (3) multiple subscribers that subscribe to
various topics they are interested in \cite{how-mqtt-works}.

This allows for decoupling of functionality at various levels. The
publisher and subscriber do not need to be close to each other and do
not need to know each others identity. They need only to know the
broker, as the publisher and the subscribers do not have to be running
either at the same time nor on the same hardware
\cite{hivemq-details}.


\subsection{Topics}

MQTT implements a hierarchy of topics that are relates
to all messages. These topics are recognised by strings separated by a
forward-slash ( / ), where each part represents a different topic
level. This is a common model introduced in file systems but also in
internet URLs. 

A topic looks therefore as follows: {\em topic-level0/topic-level1/topic-level2}.


%
% GREGOR WILL LOOK AT REST
%


All subscribers subscribe to different topics via the broker.
Subscribing to {\em topic-level0} allows the subscriber to receive all
messages that are associated with topics that start with {\em
  topic-level0}. This allows subscribers to filter what messages to
receive based on the topic hierarchy. Thus, when a publisher publishes
a message related to a topic to the broker, the message is forwarded
to all the clients that have subscribed to the topic of the message or
a topic that has a lower depth of hierarchy \cite{hivemq-details}
\cite{how-mqtt-works}.

This is different from traditional message queues as the message is
forwarded to multiple subscribers, and allows for a more flexible
approach with the help of topics \cite{hivemq-details}. The basic
steps in an MQTT client application include connecting to the broker,
subscribing to some topics, waiting for messages and performing the
appropriate action when a certain message is received
\cite{mqtt-wiki}.
 
\subsection{Callbacks}

One of the main advantages of using MQTT is that it allows
asynchronous behaviour with the help of callbacks. Both the publisher
and subscriber do not have to wait to publish a message or receive
one, and can perform other tasks in a non blocking manner
\cite{hivemq-details} \cite{python-paho-mqtt}.

The paho-mqtt package for python provides callbacks methods like
on-connect(), on-message() and on-disconnect(), which are fired when
the connection to the broker is complete, a message is received from
the broker, and when the client is disconnected from the broker
respectively. These methods are used in conjunction with the
loop-start() and loop-end() methods which start and end an
asynchronous loop that listens for these events and fires the relevant
callbacks, allowing the clients to perform other tasks
\cite{python-paho-mqtt}.

\subsection{Quality of Service}

MQTT has been designed to be flexible and options are provided to
easily change the quality of service (QoS) as required by the
application. Three basic levels of QoS are supported by the protocol,
Atmost-once (QoS level 0), Atleast-once (QoS level 1) and Atmost-once
(QoS level 2) \cite{hivemq-qos}\cite{python-paho-mqtt}.

The QoS level of 0 can be used in applications where some dropped
messages may not affect the application. Under this QoS level, the
broker forwards a message to the subscribers only once and does not
wait for any acknowledgement \cite{hivemq-qos}
\cite{python-paho-mqtt}.

The QoS level of 1 can be used in situations where the delivery of all
messages is important and the subscriber can handle duplicate
messages. Here the broker keeps on resending the message to a
subscriber after a certain timeout until the first acknowledgement is
received. A QoS level of 3 should be used in cases where all messages
must be delivered and no duplicate messages should be allowed. In this
case the broker sets up a handshake with the subscriber to check for
its availability before sending the message \cite{hivemq-qos}
\cite{python-paho-mqtt}.

The various levels of quality of service allow the use of this
protocol in a variety of applications.

\section{Security with MQTT}

The MQTT specification uses TCP/IP to deliver the messaged to the
subscribers, but it does not provide any form of security by default
to make is useful for resource constrained IoT devices. ``It allows
the use of username and password for authentication, but by default
this information is sent as plain text over the network, making it
susceptible to man-in-the middle attacks''
\cite{iot-design-mqtt-security} \cite{mqtt-sec-ssl}. Therefore, in
sensitive applications some form of additional security measures are
recommended which may include network layer security with the use of
Virtual Private Networks (VPNs), Transport Layer Security, or
application layer security \cite{mqtt-sec-ssl}.

\subsection{Using TLS/SSL}

Transport Layer Security (TLS) and Secure Sockets Layer (SSL) are
cryptographic protocols that establish a the identity of the server
and client with the help of a handshake mechanism which uses trust
certificates to establish identities before encrypted communication
can take place \cite{ibm-mqtt-security}. If the handshake is not
completed for some reason, the connection is not established and no
messages are exchanged \cite{mqtt-sec-ssl}. ``Most MQTT brokers
provide an option to use TLS instead of plain TCP and port 8883 has
been standardized for secured MQTT connections''
\cite{iot-design-mqtt-security}.

Using TLS/SSL security however comes at an additional cost. If the
connections are short-lived then most of the time can be spent in the
handshake itself, which may take up few kilobytes of bandwidth. In
case the connections are short-lived, temporary session IDs and
session tickets can be used to resume a session instead of repeating
the handshake process. If the connections are long term, the overhead
of the handshake is negligible and TLS/SSL security should be used
\cite{iot-design-mqtt-security}\cite{mqtt-sec-ssl}.

\subsection{Using OAuth}

OAuth is an open protocol that allows access to a resource without
providing unencrypted credentials to the third party. Although MQTT
protocol itself does not include authorization, many MQTT brokers
include authorization as an additional feature
\cite{ibm-mqtt-security}. OAuth2.0 uses JSON Web Tokens which contain
information about the token ans the user and are signed by a trusted
authorization server \cite{hivemq-security-oauth}.

When connecting to the broker this token can be used to check whether
the client is authorised to connect at this time or not. Additionally
the same validations can be used when publishing or subscribing to the
broker. The broker may use a third party resource such as LDAP
(lightweight directory access protocol) to look up authorizations for
the client \cite{hivemq-security-oauth}. Since there can be a large
number of clients and it can become impractical to authorize everyone,
clients may be grouped and the authorizations may be checked for each
group \cite{ibm-mqtt-security}.
  
\section{Integration with Other Services}

As the individual IoT devices perform their respective functions in
the sensor network, a lot of data is generated which needs to be
processed. MQTT allows easy integration with other services, that have
been designed to process this data.

Apache storm is a distributed processing system that allows real time
processing of continuous data streams, much like Hadoop works for
batch processing \cite{apache-storm}. Apache storm can be easily
integrated with MQTT as shown in \cite{apache-storm-mqtt} to get real
time data streams and allow analytics and online machine learning in a
fault tolerant manner \citep{apache-storm-wiki}.

ELK stack (elastic-search, logstash and kibana) is an opensource
project designed for scalability which contains three main software
packages, the {\em elastic-search} search and analytics engine, {\em
  logstash} which is a data collection pipeline and {\em kibana} which
is a visualization dashboard \cite{elk-stack}. Data from an IoT
network can be collected, analysed and visualized easily with the help
of the ELK stack as shown in \cite{mqtt-elasticsearch-setup} and
\cite{kibana-mqtt-analysis}.

MQTT broker services can be utilized for enterprise and production
environments. EMQ (Erlang MQTT Broker) provides a highly scalable,
distributed and reliable MQTT broker that can be used in
enterprise-grade applications \cite{erlang-mqtt-broker}.


\section{Use Case}

MQTT can be used in a variety of applications. This section explores a
particular use case of the protocol. A small network was set up with
three devices to simulate an IoT environment, and actuators were
controlled with the help of messages communicated over MQTT.

\subsection{Requirements and Setup}

The setup used three different machines. A laptop or a desktop running
the MQTT broker, and two raspberry pis configured with raspbean
operating system. Eclipse Paho MQTT client was setup on each of the
raspberry pis \cite{python-paho-mqtt}. Additionally all three devices
were connected to an isolated local network.

Grovepi shields for the raspberry pis, designed by Dexter Industries
were used on each of the raspberry pis to connect the actuators as
they allow easy connections ot the raspberry pi board \cite{grovepi}.
The actuators used were Grove relays \cite{grove-relay} and Grove LEDs
\cite{grove-led} which respond to the messages received via MQTT.

To control the leds and relays, the python library cloudmesh.pi
\cite{cloudmesh.pi}, developed at Indiana University was used. The
library consists of interfaces for various IoT sensors and actuators
and can be easily used with the grove modules.

%sma controlled dendrites
%install instructions
%block diagram figure

%actual picture of setup ?

\subsection{Results}

The two raspberry pis subscribe connect to the broker and subscribe
with different topics. The raspberry pis wait for any messages from
the broker. A publisher program that connects to the broker publishes
messages to the broker for the topics that the two raspberry pis had
registered. Each raspberry pi receives the corresponding message and
turns the LEDs or relays on or off as per the message.

On a local network this process happens in near real time and no
delays were observed. Eclipse IoT MQTT broker ({\em iot.eclipse.org})
was also tried which also did not result in any significant delays.

Thus it is observed that two raspberry pis can be easily controlled
using MQTT. This system can be extended to incude arbitrary number of
raspberry pis and other devices that subscribe to the broker. If a
device fails, or the connection from one device is broken, other
devices are not affected and continue to perform the same.

This project can be extended to include various other kinds of sensors
and actuators. The actuators may subscribe to topics to which various
sensors publish their data ans respond accordingly. The data of these
sensors can be captured with the help of a data collector which may
itself be a different subscriber, that performs analytics or
visualizations on this data.

%code link

\section{Conclusion}

We see that as the number of connected devices increases and their
applications become commonplace, MQTT allows different devices to
communicate with each other in a data agnostic manner. MQTT uses a
publish-subscribe model and allows various levels of quality of
service requirements to be fulfilled. Although MQTT does not provide
data security by default, most brokers allow the use of TLS/SSL to
encrypt the data. Additional features may be provided by the broker to
include authorization services. MQTT can be easily integrated with
other services to allow collection and analysis of data. A small
environment was simulated that used MQTT broker and clients running on
raspberry pis to control actuators

\bibliographystyle{ACM-Reference-Format}
\bibliography{report} 

%\input{issues}

\end{document}
