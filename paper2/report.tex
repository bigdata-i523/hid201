\documentclass[sigconf]{acmart}

\input{format/i523}

\begin{document}
\title{Using MQTT for Communication in IoT Applications}


\author{Arnav}
\affiliation{%
  \institution{Indiana University Bloomington}
  \city{Bloomington} 
  \state{Indiana} 
  \postcode{47408}
}
\email{aarnav@iu.edu}

\author{Gregor von Laszewski}
\affiliation{%
  \institution{Indiana University}
  \streetaddress{Smith Research Center}
  \city{Bloomington} 
  \state{IN} 
  \postcode{47408}
  \country{USA}
}
\email{laszewski@gmail.com}


% The default list of authors is too long for headers}
% \renewcommand{\shortauthors}{G. v. Laszewski}


\begin{abstract}
With the increse in the number of edge devices and their applications in settings like sensor networks, it is crucial to allow communication between the sensing devices and actuators, which may not be directly connectes. To allow services built on various different platforms and using different hardware to commmunicate , a data agnostic, fast and reliable mechanism is needed to allow communication between these devices. In addiion to communication, the data generated by these devices must be analyzed and security of this data is highly important. MQTT is a common, easy to use, queing protocol that helps meet these requirements.
\end{abstract}

\keywords{i523, HID201, MQTT, IoT, Edge Computing, Security}


\maketitle



\section{Introduction}
As Internet of Things (IoT) applications and sensor networks become commonplace and more and more devices are being connected, there is a need to allow these devices to communicate. It is often the case that these edge devices have a very limited memory and need to conserve power, and may not have enough computing capacity to process traditional HTTP web requests efficiently \cite{mqtt-vs-http}\cite{hivemq-website}. Monitoring the state of a remotely located sensor using HTTP would require sending requests and recieving responses to and from the device frequently, which may not be efficient on small chips on these sensors \cite{mqtt-vs-http}.

Message Queue Telemetry Transport (MQTT) is a lightweight machine to machine (M2M) messaging protocol, based on a client/server based publish-subscribe model, that is an elegant solution for such scenarios. MQTT was first  developed in 1999 by Andy Stanford-Clark and Arlen Nipper to connect oil pipelines \cite{hivemq-website}. The protocol has been designed to be used on top of TCP/IP protocol in situations where network bandwidth, and available memory are limited allowing low power usage. It allows efficient transmission of data to various devices listening for the same event, and is scalable as the number of devices increase \cite{mqtt-wiki}\cite{mqtt-official}. 

``Eclipse Paho project, maintained by eclipse iot, MQTT clients for various languages such as C, Python and Lua. It also includes an open source Mosquitto broker and a Really Small Message Broker from IBM'' \cite{mqtt-official}\cite{eclipse-mosquitto}.


\section{MQTT Details}
MQTT works on a publish-subscribe model, which contains 3 entities, a publisher, that sends a message, a broker, that maintains queue of all messages based on topics and multiple subscribers that subscribe to various topics they are interested in \cite{how-mqtt-works}.

This allows for decoupling of functionality at various levels. The publisher and subscriber do not need to be close to each other and do not need to know each others identity but only that of the broker and the publisher and the subscribers do not have to be running at the same time \cite{hivemq-details}.

\subsection{Topics}
MQTT uses a cleverly designed hierarchy of topics, which are related to all messages. These topics are recognised by strings separated by a forward-slash ( / ) and each part representing a different topic level.

For example {\em topic-level0/topic-level1/topic-level2}.

All subscribers subscribe to different topics via the broker. Subscribing to {\em topic-level0} allows the subscriber to recieve all messages that are associated with topics that start with {\em topic-level0}. This allows subscribrs to filter what messages to recieve based on the topic hierarchy.
Thus, when a publisher publishes a message related to a topic to the broker, the message is forwarded to all the clients that have subscribed to the topic of the message or a topic that has a lower depth of hierarchy \cite{hivemq-details} \cite{how-mqtt-works}.

This is different from traditional message queues as the message is forwarded to multiple subscribers, and allows for a more flexible approach with the help of topics \cite{hivemq-details}. The basic steps in an MQTT client application include connecting to the broker, subscribing to some topics, waiting for messages and performing the appropriate action when a certain message is received \cite{mqtt-wiki}.
 
\subsection{Callbacks}
One of the main advantages of using MQTT is that it allows asynchronous behaviour withthe help of callbacks. Both the publisher and subscriber do not have to wait to publish a message or receive one, and can perform other tasks in a non blocking manner \cite{hivemq-details} \cite{python-paho-mqtt}.

The paho-mqtt pachage for python provides callbacks methods like on-connect(), on-message() and on-disconnect(), which are fired when the connection to the broker is complete, a message is received from the broker, and when the client is disconnected from the broker respectively. These methods are used in conjunction with the loop-start() and loop-end() methods which start and end an asynchronous loop that listens for these events and fires the relevant callbacks, allowing the clients to perform other tasks \cite{python-paho-mqtt}.

\subsection{Quality of Service}
MQTT has been designed to be flexible and options are provided to easily change the quality of service (QoS) as required by the application. Three basic levels of QoS are supported by the protocol, Atmost-once (QoS level 0), Atleast-once (QoS level 1) and Atmost-once (QoS level 2) \cite{hivemq-qos}\cite{python-paho-mqtt}.

The QoS level of 0 can be used in applcations where some droped messages may not affect the application. Under this QoS level, the broker forwards a message to the sunscribers only once and does not wait for any acknowledgement \cite{hivemq-qos} \cite{python-paho-mqtt}.
The QoS level of 1 can be used in situations where the delivery of all messages is important and the subscriber can handle duplicate messages. Here the broker keeps on resending the message to a subscriber after a certain timeout until the first acknowledgement is received.
A QoS level of 3 should be used in cases where all messages must be delivered and no duplicate messages should be allowed. In this case the broker sets up a handshake with the subscriber to check for its availability before sending the message \cite{hivemq-qos} \cite{python-paho-mqtt}.

The various levels of quality of service allow the use of this protocol in a variety of applications.

\section{Security with MQTT}
The MQTT specification uses TCP/IP to deliver the messaged to the subscribers, but it does not provide any form of security by default to make is useful for resource constrained IoT devices. ``It allows the use of username and password for authentication, but by default this information is sent as plain text over the network, making it susceptible to man-in-the middle attacks'' \cite{iot-design-mqtt-security} \cite{mqtt-sec-ssl}. Therefore, in sensitive applications some form of additional security measures are recommended which may include network layer security with the use of Virtual Private Networks (VPNs), Transport Layer Security, or application layer security \cite{mqtt-sec-ssl}. 

\subsection{Using TLS/SSL}
Transport Layer Security (TLS) and Secure Sockets Layer (SSL) are cryptographic protocols that establish a the identity of the server and client with the help of a handshake mechanism which uses trust certificates to establish identities before encrypted communication can take place \cite{ibm-mqtt-security}. If the handshake is not completed for some reason, the connection is not established and no messages are exchanged \cite{mqtt-sec-ssl}. ``Most MQTT brokers provide an option to use TLS instead of plain TCP and port 8883 has been standardized for secured MQTT connections'' \cite{iot-design-mqtt-security}.

Using TLS/SSL security however comes at an additional cost. If the connections are shortlived then most of the time can be spent in the handshake itself, ehich may take up few kilobytes of bandwidth. In case the connections are shortlived, temoporary session IDs and session tickets can be used to resume a session instead of repeating the handshake process. If the connections are long term, the overhead of the handshake is negligibe and TLS/SSL security should be used \cite{iot-design-mqtt-security}\cite{mqtt-sec-ssl}.

\subsection{Using OAuth}
OAuth is an open protocol that allows access to a resource without providing unencrypted credentials to the third party. Although MQTT protocol itself does not include authorization, many MQTT brokers include authorization as an additional feature \cite{ibm-mqtt-security}. OAuth2.0 uses JSON Web Tokens which contain information about the token ans the user and are signed by a trusted authorisation server \cite{hivemq-security-oauth}.

When connecting to the broker this token can be used to check whether the client is authorised to connect at this time or not. Additionally the same validations can be used when publishing or subscribing to the broker. The broker may use a third party resource such as LDAP (lightweight directiry access protocol) to look up authorisations for the client \cite{hivemq-security-oauth}. Since there can be a large number of clients and it can become impractical to authorise everyone, clients may be grouped and the authorizations may be cheked for each group \cite{ibm-mqtt-security}.
  
\section{Integration with Other Services}
As the infividual IoT devices perform their respective functions in the sensor network, a lot of data is generated whic needs to be processed. MQTT allows easy integration with other services, that have been designed to process this data.

Apache storm is a distributed processing system that allows real time  processing of continuous data streams, much like Hadoop works for batch processing \cite{apache-storm}. Apache storm can be easily integrated with MQTT as shown in \cite{apache-storm-mqtt} to get real time data streams and allow analytics and online machine learning in a fault tolerant manner \citep{apache-storm-wiki}.

ELK stack (elastic-search, logstash and kibana) is an opensource project designed for scalability which contains three main software packages, the {\em elastic-search} search and analytics engine, {\em logstash} which is a data colection pipeline and {\em kibana} which is a visualization dashboard \cite{elk-stack}. Data from an IoT network can be collected, analysed and visualized easily with the help of the ELK stack as shown in \cite{mqtt-elasticsearch-setup} and \cite{kibana-mqtt-analysis}.

MQTT broker services can be utilised for enterprise and production environments. EMQ (Erlang MQTT Broker) provides a highly scalable, distributed and reliable MQTT broker that can be used in enterprise-grade applications \cite{erlang-mqtt-broker}. 


\section{Use Case}
MQTT can be used in a variety of applications. This section explores a particular use case of the protocol. A small network was set up with three devices to simulate an IoT environment, and actuators were controlled with the help of messages communicated over MQTT.

\subsection{Requirements and Setup}
The setup used three different machines. A laptop or a desktop running the MQTT broker, and two raspberry pis configured with raspbean operating system. Eclipse Paho MQTT client was setup on each of the raspberry pis \cite{python-paho-mqtt}. Additionally all three devices were connected to an isolated local network.

Grovepi shields for the raspberry pis, designed by Dexter Industries were used on each of the raspberry pis to connect the actuators as they allow wasy connections ot the raspberry pi board \cite{grovepi}. The actuators used were Grove relays \cite{grove-relay} and Grove LEDs \cite{grove-led} which respond to the messages recieved via MQTT.

To control the leds and relays, the python library cloudmesh.pi \cite{cloudmesh.pi}, developed at Indiana University was used. The library consists of interfaces for various IoT sensors and actuators and can be easily used with the grove modules.

%sma controlled dendrites
%install instructions
%block diagram figure

%actual picture of setup ?

\subsection{Results}

The two raspberry pis subscribe connect to the broker and subscribe with different topics. The raspberry pis wait for any messages from the broker. A publisher program that connects to the broker publishes messages to the broker for the topics that the two raspberry pis had registered. Each raspberry pi recieves the correcponding message and turns the LEDs or relays on or off as per the message.

On a local network this process happens in near real time and no delays were observed. Eclipse iot MQTT broker ({\em iot.eclipse.org}) was also tried which also did not result in any significant delays.

Thus it is observed that two raspberry pis can be easily controlled using MQTT. This system can be extended to incude arbitrary number of raspberry pis and other devices that subscribe to the broker. If a device fails, or the connection from one device is broken, other devices are not affected and continue to perform the same.

This project can be extended to include various other kinds of sensors and actuators. The actuators may subscribe to topics to which various sensors publish their data ans respond accordingly. The data of these sensors can be captured with the help of a data collector which may itself be a different subscriber, that performs analytics or visualizations on this data.

%code link
\section{Conclusion}
We see that as the number of connected devices increases and their applications become commonplace, MQTT allows different devices to communicate with each other in a data agnostic manner. MQTT uses a publish-subscribe model and allows various levels of quality of service requirements to be fulfilled. Although MQTT does not provide data security by default, most brokers allow the use of TLS/SSL to encrypt the data. Additional features may be provided by the broker to include authorization services. MQTT can be easily integrated with other services to allow collection and analysis of data. A small environment was simulated that used MQTT broker and clients running on raspberry pis to control actuators

\begin{acks}
The authors would like to thank Dr. Gregor von Laszewski for his support and suggestions to write this paper, and for providing all the hardware needed to complete the setup at smith research center.

The authors would also like to thank the Associate Instructors of the class for answering questions regarding the paper on piazza, which helped all students in the class.
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{report} 

\input{issues}

\end{document}
